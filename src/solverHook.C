#include "lduMatrix.H"
#include "smoothSolver.H"
#include "OFstream.H"
#include "OSspecific.H"

#include "solverHook.H"

using namespace Foam;

// diagonalSolver
defineTypeNameAndDebug(diagonalSolverHook, 0);

solverPerformance diagonalSolverHook::solve(
    scalarField &psi,
    const scalarField &source,
    const direction cmpt) const
{
    ldu2mtx(matrix_, fieldName_);
    return diagonalSolver::solve(psi, source, cmpt);
}

// GAMG
defineTypeNameAndDebug(GAMGSolverHook, 0);

lduMatrix::solver::addsymMatrixConstructorToTable<GAMGSolverHook>
    addGAMGHookSolverMatrixConstructorToTable_;

lduMatrix::solver::addasymMatrixConstructorToTable<GAMGSolverHook>
    addGAMGHookAsymSolverMatrixConstructorToTable_;

solverPerformance GAMGSolverHook::solve(
    scalarField &psi,
    const scalarField &source,
    const direction cmpt) const
{
    ldu2mtx(matrix_, fieldName_);
    return GAMGSolver::solve(psi, source, cmpt);
}

// PBiCG
defineTypeNameAndDebug(PBiCGHook, 0);

lduMatrix::solver::addasymMatrixConstructorToTable<PBiCGHook>
    addPBiCGHookAsymMatrixConstructorToTable_;

solverPerformance PBiCGHook::solve(
    scalarField &psi,
    const scalarField &source,
    const direction cmpt) const
{
    ldu2mtx(matrix_, fieldName_);
    return PBiCG::solve(psi, source, cmpt);
}

// PBiCGStab
defineTypeNameAndDebug(PBiCGStabHook, 0);

lduMatrix::solver::addsymMatrixConstructorToTable<PBiCGStabHook>
    addPBiCGStabHookSymMatrixConstructorToTable_;

lduMatrix::solver::addasymMatrixConstructorToTable<PBiCGStabHook>
    addPBiCGStabHookAsymMatrixConstructorToTable_;

solverPerformance PBiCGStabHook::solve(
    scalarField &psi,
    const scalarField &source,
    const direction cmpt) const
{
    ldu2mtx(matrix_, fieldName_);
    return PBiCGStab::solve(psi, source, cmpt);
}

// PCG
defineTypeNameAndDebug(PCGHook, 0);

lduMatrix::solver::addsymMatrixConstructorToTable<PCGHook>
    addPCGHookSymMatrixConstructorToTable_;

solverPerformance PCGHook::solve(
    scalarField &psi,
    const scalarField &source,
    const direction cmpt) const
{
    ldu2mtx(matrix_, fieldName_);
    return PCG::solve(psi, source, cmpt);
};

// smoothSolver
defineTypeNameAndDebug(smoothSolverHook, 0);

lduMatrix::solver::addsymMatrixConstructorToTable<smoothSolverHook>
    addsmoothSolverHookSymMatrixConstructorToTable_;

lduMatrix::solver::addasymMatrixConstructorToTable<smoothSolverHook>
    addsmoothSolverHookAsymMatrixConstructorToTable_;

solverPerformance smoothSolverHook::solve(
    scalarField &psi,
    const scalarField &source,
    const direction cmpt) const
{
    ldu2mtx(matrix_, fieldName_);
    return smoothSolver::solve(psi, source, cmpt);
}

// others
void ldu2mtx(const lduMatrix &matrix, const word &field)
{
    const lduAddressing &ldu_addr = matrix.mesh().lduAddr();
    const labelUList &upper_addr = ldu_addr.upperAddr();
    const labelUList &lower_addr = ldu_addr.lowerAddr();
    const scalarField &diag = matrix.diag();
    const scalarField &upper = matrix.upper();
    const scalarField &lower = matrix.lower();
    const label mn = diag.size();
    const label nnz = diag.size() + 2 * ldu_addr.size();
    const fileName directory("mtx/" + field);
    mkDir(directory);
    autoPtr<OFstream> path;
    path.reset(new OFstream(directory / strize(next(field))));
    *path << "%%MatrixMarket matrix coordinate real general" << nl
          << "%" << nl
          << "% Auto generated by code" << nl
          << "%" << nl
          << mn << " " << mn << " " << nnz << nl;
    forAll(ldu_addr, ith)
    {
        *path << upper_addr[ith] + 1 << " " << lower_addr[ith] + 1 << " " << upper[ith] << nl
              << lower_addr[ith] + 1 << " " << upper_addr[ith] + 1 << " " << lower[ith] << nl;
    }
    forAll(diag, ith)
    {
        *path << ith + 1 << " " << ith + 1 << " " << diag[ith] << nl;
    }
}

label next(const word &field)
{
    static HashTable<label, word> counter(128);
    if (counter.found(field))
    {
        counter[field]++;
    }
    else
    {
        counter.insert(field, 1);
    }
    return counter[field] - 1;
}

word strize(label value)
{
    return std::to_string(value);
}
